#### 5.3 ダックタイピングへの恐れを克服する

##### 静的型付けによるダックタイプの無効化

動的型付けを恐れるプログラマーは、コード内でオブジェクトのクラスを検査する傾向にある

この検査こそ、まさに動的型付けの力を削ぐものであり、ダックタイプの利用を不可能にしている

クラスへの依存を取り除くことで、続発する型の失敗を避けることができる

##### 静的型付けと動的型付け

静的型付けの支持者は、以下の特性をあげる

- コンパイラがコンパイル時に型エラーを発見してくれる
- 可視化された型情報は、文書の役割も果たしてくれる
- コンパイルされたコードは最適化され、高速に動作する

**以下の対応する仮定を認める場合にのみ**、上記の利点はプログラミング言語における強みとなるだろう

- コンパイラが型を検査しない限り、実行時の型エラーが起こる
- 型がなければプログラマーはコードを理解できない。プログラマーはオブジェクトのコンテキストからその型を推測することができない
- 一連の最適化がなければ、アプリケーションの動作は遅くなりすぎる

動的型付けの支持者は、以下の特性を挙げる

- コードは逐次実行され、動的に読み込まれる。そのため、コンパイル/make のサイクルがない
- ソースコードは明示的な型情報を含まない
- メタプログラミングがより簡単

これらの特性は、以下の仮定を認める場合に強みとなる

- アプリケーション全体の開発は、コンパイル/make のサイクルがないほうが高速
- 型宣言がコードに含まれないときのほうがプログラマーにとって理解するのが簡単。そのコンテキストからオブジェクトの型は推測できる
- メタプログラミングは、あることが望ましい言語機能

##### 動的型付けを受け入れる

メタプログラミングは、賢く使えば、大いなる価値を発揮する。メタプログラミングの容易さは、動的型付けを支持する有力な論拠である

静的型付けの前提

- コンパイラは不慮の型エラーから本当に救って「くれる」
- コンパイラの助けなしでは、これらの型エラーは「起こる」

動的型付けの答え

「救ってくれない」し「エラーは起きない」
