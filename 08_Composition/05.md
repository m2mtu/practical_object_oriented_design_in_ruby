#### 8.5 コンポジションと継承の選択

コンポジションでは、オブジェクトは独立して存在する。そしてその結果、オブジェクトは互いについて明示的に知識を持ち、明示的にメッセージを移譲する必要がある

直面した問題がコンポジションによって解決できるものであれば、まずはコンポジションで解決することを優先すべき

コンポジションが持つ依存は、継承が持つ依存よりもはるかに少ない

##### 継承による影響を認める

◉ 継承の利点

継承を使った結果得られるコードは、「オープン・クローズド (Open-Closed)」と特徴付けられるものとなる

階層構造は、拡張には開いており (open)、修正には閉じている (closed)

Ruby ではNumeric クラスがある。Integer とFloat はNumeric のサブクラスとしてモデル化されている

この「is-a」の関係は全く正しい。整数と浮動小数点数は、どちらとも根本的には「数字」である

◉ 継承のコスト

1. 継承が適さない問題に対して、誤って継承を選択してしまうこと

2. 問題に対して継承の適用が妥当であったとしても、自分が書いているコードが他のプログラマーによって、全く予期していなかった目的のために使われるかもしれないこと

継承では、「自分が間違っている時、何が起こるだろう」という問いかけが特別に重要な意味を帯びてくる

##### コンポジションの影響を認める

◉ コンポジションの利点

小さなオブジェクトは単一の責任を持ち、自身の振る舞いを限定している。それらは「見通しが良い」ものである

コンポーズされたオブジェクトが階層構造から独立しているということは、コンポーズされたオブジェクトはほんのわずかなコードしか継承せず、それゆえ、それより上の階層構造にあるクラスへの変更によって生じる副作用に悩まされることは一般的にはない

コンポジションに参加するオブジェクトは小さく、構造的に独立しており、そして適切に定義されたインターフェースを持つ

それらは、抜き差し可能で、入れ替え可能なコンポーネントへと円滑に移行できる

従って、適切にコンポーズされたオブジェクトは「利用性が高く」、想定していなかった新たなコンテキストでも簡単に利用できる

◉ コンポジションのコスト

コンポーズされたオブジェクトは、多くのパーツに依存する。それぞれの部品は小さく、簡単に理解できるものであったとしても、組み合わされた全体の動作は、理解しやすいとはいえない

構造的な独立性の利点は、メッセージの自動的な移譲を犠牲にすることで得られている

コンポーズされたオブジェクトは、明示的にどのメッセージを誰に移譲するかを必ず知っていなければならない

コンポジションは、パーツから成るオブジェクトの、組み立て方のルールを規定するにはとても優れている

しかし、ほぼ同一なパーツが集まっているコードを構成する問題に対しては、そこまでの助けにはならない

##### 関係の選択

- 継承とは、特殊化です (Bertrand Meyer, *Touch of Class: Learning to Program Well with Objects and Contracts*)
- 継承が最も適しているのは、過去のコードの大部分を使いつつ、新たなコードの追加が比較的少量の時に、既存のクラスに機能を追加する場合です (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, *Design Patterns: Elements of Reusable Object-Oriented Software*)
- 振る舞いが、それを構成するパーツの総和を上回るのなら、コンポジションを使いましょう (Grady Booch, *Object-Oriented Analysis and Design*、意訳)

◉ behaves-like-a 関係にダックタイプを使う

ロールの存在を認識するための、鍵となる状況

1. あるオブジェクトが何かロールを担っているにもかかわらず、そのロールがそのオブジェクトの主な責任ではないとき
2. 必要性が幅広い時。いくつもの、ともすると互いに関係しないオブジェクトが、同じロールを担いたいという欲求を共有する時

◉ has-a 関係にコンポジションを使う

Bicycle はParts を持つ (Bicycles have-a Parts)。しかし、自転車自体は何かそれ以上のものである

自転車は、そのパーツの振る舞いだけでなく、そこに追加の振る舞いと、そのパーツの振る舞いとは独立した振る舞いを持つ


